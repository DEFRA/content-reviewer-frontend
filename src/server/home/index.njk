{% extends 'layouts/page.njk' %}

{% block head %}
  {{ super() }}
  <style nonce="{{ cspNonce }}">
    /* Animated loading dots */
    .loading-dots {
      display: inline-block;
      margin-left: 2px;
    }
    .loading-dots span {
      animation: blink 1.4s infinite;
      animation-fill-mode: both;
    }
    .loading-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }
    .loading-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }
    @keyframes blink {
      0%, 80%, 100% { opacity: 0; }
      40% { opacity: 1; }
    }
    .upload-progress-bar {
      background: #1d70b8;
      height: 10px;
      border-radius: 5px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .text-align-right { text-align: right; }
    .margin-bottom-0 { margin-bottom: 0; }
    .inline-block { display: inline-block; }
    .margin-right-10 { margin-right: 10px; }
    .width-auto { width: auto; }
    .display-inline { display: inline; }
    
    /* Pagination styles */
    .pagination {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin: 20px 0;
      padding: 20px 0;
      border-top: 1px solid #b1b4b6;
      border-bottom: 1px solid #b1b4b6;
    }
    .pagination-item {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
      height: 40px;
      padding: 0 8px;
      text-decoration: none;
      border: 1px solid #b1b4b6;
      background-color: #fff;
      color: #1d70b8;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .pagination-item:hover:not(:disabled):not(.pagination-current) {
      background-color: #f3f2f1;
    }
    .pagination-item:focus {
      outline: 3px solid #ffbf47;
      outline-offset: 0;
    }
    .pagination-item:disabled,
    .pagination-item[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
    .pagination-current {
      background-color: #1d70b8;
      color: #fff;
      border-color: #1d70b8;
      text-decoration: underline;
      font-weight: bold;
    }
    .pagination-arrow {
      font-size: 20px;
      line-height: 1;
    }
    .pagination-info {
      margin-top: 10px;
      text-align: center;
      color: #505a5f;
      font-size: 14px;
    }
  </style>
{% endblock %}

{% block content %}
  <div class="govuk-grid-row">
    <div class="govuk-grid-column-full">
      
      <h1 class="govuk-heading-l">Content Review Assistant</h1>
      
      <!-- Upload Success Message -->
      {% if uploadSuccess %}
      <div class="govuk-notification-banner govuk-notification-banner--success" role="alert" aria-labelledby="upload-success-title" data-module="govuk-notification-banner">
        <div class="govuk-notification-banner__header">
          <h2 class="govuk-notification-banner__title" id="upload-success-title">
            Success
          </h2>
        </div>
        <div class="govuk-notification-banner__content">
          <h3 class="govuk-notification-banner__heading">
            Document uploaded successfully
          </h3>
          <p class="govuk-body">
            <strong>{{ uploadSuccess.filename }}</strong> ({{ (uploadSuccess.size / 1024) | round(2) }} KB) has been uploaded and scanned.
          </p>
        </div>
      </div>
      {% endif %}

      <!-- Upload Error Message -->
      {% if uploadError %}
      <div class="govuk-error-summary" aria-labelledby="error-summary-title" role="alert" tabindex="-1" data-module="govuk-error-summary">
        <h2 class="govuk-error-summary__title" id="error-summary-title">
          Upload failed
        </h2>
        <div class="govuk-error-summary__body">
          <p class="govuk-body">{{ uploadError }}</p>
        </div>
      </div>
      {% endif %}

      <p class="govuk-body">
        Type or paste content below for review. The content will be analyzed for clarity, formatting and compliance with GOV.UK standards.
      </p>

      <!-- Content Review Form -->
      <div class="govuk-!-margin-bottom-6">
        <form id="uploadForm" enctype="multipart/form-data">
          
          <!-- Upload Error Message (Dynamic) -->
          <div id="uploadError" class="govuk-error-summary" hidden aria-labelledby="error-summary-title" role="alert" tabindex="-1">
            <h2 class="govuk-error-summary__title" id="error-summary-title">
              Upload failed
            </h2>
            <div class="govuk-error-summary__body">
              <p class="govuk-body" id="errorMessage"></p>
            </div>
          </div>

          <!-- Upload Success Message (Dynamic) -->
          <div id="uploadSuccess" class="govuk-notification-banner govuk-notification-banner--success" role="alert" hidden>
            <div class="govuk-notification-banner__header">
              <h2 class="govuk-notification-banner__title">Success</h2>
            </div>
            <div class="govuk-notification-banner__content">
              <p class="govuk-body" id="successMessage"></p>
            </div>
          </div>

          <!-- File Upload Option - COMMENTED OUT - File upload functionality disabled for demo -->
          <!-- <div class="govuk-form-group" id="fileFormGroup">
            <label class="govuk-label govuk-label--s" for="file-upload">
              Upload a document (optional)
            </label>
            <div class="govuk-hint">
              Accepted file types: PDF (.pdf), Word (.doc, .docx). Maximum file size: 10MB
            </div>
            <input class="govuk-file-upload" id="file-upload" name="file" type="file" accept=".pdf,.doc,.docx,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
            <div id="file-name-display" class="govuk-hint govuk-!-margin-top-2 js-hidden">
              Selected: <strong id="selected-file-name"></strong>
            </div>
          </div> -->

          <!-- Text Content Option -->
          <div class="govuk-form-group" id="textFormGroup">
            <label class="govuk-label govuk-label--s" for="text-content">
              Type/paste your content directly
            </label>
            <textarea 
              class="govuk-textarea" 
              id="text-content" 
              name="textContent" 
              rows="8" 
              placeholder="Type or paste content here..."
              aria-describedby="text-content-hint"
            ></textarea>
          </div>
          
          <button 
            type="submit" 
            class="govuk-button"
            data-module="govuk-button"
            id="uploadButton"
          >
            Review Content
          </button>

          <!-- Upload Progress Indicator -->
          <div id="uploadProgress" class="govuk-!-margin-top-4" hidden>
            <div class="govuk-inset-text">
              <p class="govuk-body" id="uploadStatusText"></p>
              <div class="govuk-!-margin-top-2">
                <div id="progressBar" class="upload-progress-bar" data-progress="0"></div>
                <p class="govuk-body govuk-!-margin-top-1" id="uploadProgressText"></p>
              </div>
            </div>
          </div>
        </form>
      </div>

      <!-- Document Review History Table -->
      <div class="govuk-grid-row govuk-!-margin-top-8">
        <div class="govuk-grid-column-one-half">
          <h2 class="govuk-heading-m">Review History</h2>
        </div>
        <div class="govuk-grid-column-one-half text-align-right">
          <form id="reviewLimitForm" method="get" class="display-inline">
            <label class="govuk-label inline-block margin-right-10" for="reviewLimit">
              Show latest:
            </label>
            <select class="govuk-select width-auto inline-block" id="reviewLimit" name="limit">
              <option value="5" {% if (currentLimit == 5) %}selected{% endif %}>5 reviews</option>
              <option value="10" {% if (currentLimit == 10) %}selected{% endif %}>10 reviews</option>
              <option value="50" {% if (currentLimit == 50) %}selected{% endif %}>50 reviews</option>
              <option value="100" {% if (currentLimit == 100) %}selected{% endif %}>100 reviews</option>
            </select>
          </form>
        </div>
      </div>
        
      <table class="govuk-table" id="reviewHistoryTable">
        <thead class="govuk-table__head">
          <tr class="govuk-table__row">
            <th scope="col" class="govuk-table__header">Uploaded Content</th>
            <th scope="col" class="govuk-table__header">Status</th>
            <th scope="col" class="govuk-table__header">Timestamp</th>
            <th scope="col" class="govuk-table__header">Result</th>
            <th scope="col" class="govuk-table__header">Actions</th>
          </tr>
        </thead>
        <tbody class="govuk-table__body" id="reviewHistoryBody">
          {% if reviewHistory and reviewHistory.length > 0 %}
            {% for review in reviewHistory %}
            <tr class="govuk-table__row" data-review-id="{{ review.reviewId or review.id }}">
              <td class="govuk-table__cell">{{ review.filename }}</td>
              <td class="govuk-table__cell">
                {% if review.status === 'completed' %}
                  <strong class="govuk-tag govuk-tag--green">Completed</strong>
                {% elif review.status === 'processing' %}
                  <strong class="govuk-tag govuk-tag--blue">Processing...</strong>
                {% elif review.status === 'pending' %}
                  <strong class="govuk-tag govuk-tag--yellow">Pending...</strong>
                {% elif review.status === 'failed' %}
                  <strong class="govuk-tag govuk-tag--red">Failed</strong>
                {% else %}
                  <strong class="govuk-tag govuk-tag--grey">{{ review.status | title }}</strong>
                {% endif %}
              </td>
              <td class="govuk-table__cell">
                {% if review.uploadedAt %}
                  {{ review.uploadedAt | formatDate('dd/MM/yyyy, HH:mm') }}
                {% else %}
                  N/A
                {% endif %}
              </td>
              <td class="govuk-table__cell">
                {% if review.status === 'completed' %}
                  {% if review.reviewId or review.id %}
                    <a href="/review/results/{{ review.reviewId or review.id }}" class="govuk-link">View results</a>
                  {% else %}
                    <span class="govuk-hint">Missing review ID</span>
                  {% endif %}
                {% elif review.status === 'failed' %}
                  {% if review.errorMessage %}
                    <span class="govuk-error-message">Review Failed ({{ review.errorMessage }})</span>
                  {% else %}
                    <span class="govuk-error-message">Review Failed</span>
                  {% endif %}
                {% elif review.status === 'processing' %}
                  <span class="govuk-body">Processing...</span>
                {% elif review.status === 'pending' %}
                  <span class="govuk-body">Pending...</span>
                {% else %}
                  <span class="govuk-body">{{ review.status }}</span>
                {% endif %}
              </td>
              <td class="govuk-table__cell">
                <button 
                  class="govuk-button govuk-button--warning govuk-button--small delete-review-btn" 
                  data-review-id="{{ review.reviewId or review.id }}"
                  data-filename="{{ review.filename }}"
                  type="button">
                  Delete
                </button>
              </td>
            </tr>
            {% endfor %}
          {% else %}
            <tr class="govuk-table__row">
              <td class="govuk-table__cell" colspan="4">
                <p class="govuk-body">No review history available.</p>
              </td>
            </tr>
          {% endif %}
        </tbody>
      </table>

      <!-- Pagination Controls -->
      {% if pagination and pagination.totalPages > 1 %}
      <div class="pagination">
        <!-- Previous Arrow -->
        <a 
          href="?limit={{ currentLimit }}&page={{ pagination.currentPage - 1 }}" 
          class="pagination-item pagination-arrow"
          {% if not pagination.hasPreviousPage %}disabled{% endif %}
          aria-label="Previous page"
        >
          &#60;
        </a>
        
        <!-- Page Numbers -->
        {% for page in range(1, pagination.totalPages + 1) %}
          {% if page == pagination.currentPage %}
            <span class="pagination-item pagination-current" aria-current="page">{{ page }}</span>
          {% else %}
            <a 
              href="?limit={{ currentLimit }}&page={{ page }}" 
              class="pagination-item"
              aria-label="Go to page {{ page }}"
            >
              {{ page }}
            </a>
          {% endif %}
        {% endfor %}
        
        <!-- Next Arrow -->
        <a 
          href="?limit={{ currentLimit }}&page={{ pagination.currentPage + 1 }}" 
          class="pagination-item pagination-arrow"
          {% if not pagination.hasNextPage %}disabled{% endif %}
          aria-label="Next page"
        >
          &#62;
        </a>
      </div>
      
      <div class="pagination-info">
        Showing {{ (pagination.currentPage - 1) * pagination.pageSize + 1 }} to 
        {{ [pagination.currentPage * pagination.pageSize, pagination.totalReviews] | min }} 
        of {{ pagination.totalReviews }} reviews
      </div>
      {% endif %}

    </div>
  </div>

{% endblock %}

{% block bodyEnd %}
  {{ super() }}
  <script nonce="{{ cspNonce }}" src="{{ getAssetPath('upload-handler.js') }}"></script>
  <script nonce="{{ cspNonce }}">
    console.log('[HOME] Page loaded');
    // ============ AUTO-REFRESH LOGIC ============
    // Note: Upload form handling is now in upload-handler.js
    // Auto-refresh state
    let autoRefreshInterval = null;
    let isRefreshing = false;
    
    // Get the current limit from dropdown
    function getCurrentLimit() {
      const limitSelect = document.getElementById('reviewLimit');
      return parseInt(limitSelect?.value, 5);
    }
    
    // Add event listener to dropdown
    const limitSelect = document.getElementById('reviewLimit');
    if (limitSelect) {
      limitSelect.addEventListener('change', function() {
        this.form.submit();
      });
    }
    
    // Function to update review history without page reload
    async function updateReviewHistory() {
      if (isRefreshing) return; // Prevent concurrent requests
      
      isRefreshing = true;
      try {
        const limit = document.getElementById('reviewLimit')?.value || 5;
        // Call frontend proxy route instead of backend directly to avoid CORS issues
        const response = await fetch(`/api/reviews?limit=${limit}`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json'
          }
        })
        
        if (!response.ok) {
          console.error('[HOME] Failed to fetch review history:', response.status);
          // Stop auto-refresh on error to prevent spam
          if (autoRefreshInterval) {
            clearInterval(autoRefreshInterval);
            autoRefreshInterval = null;
          }
          return;
        }
        
        const data = await response.json();
        
        // Normalize review data for client-side rendering
        const normalized = (data.reviews || []).map(r => {
          // Determine filename - preserve the original if it exists
          let displayFilename = r.fileName || r.filename;
          
          // If fileName/filename is missing or empty for text content, use first 10 chars
          if (!displayFilename || displayFilename === 'Text Content') {
            // Try to get from content if available, otherwise keep 'Text Content'
            displayFilename = r.fileName || r.filename || 'Text Content';
          }
          
          return {
            ...r,
            filename: displayFilename,
            // Use lastModified (S3 LastModified) for most accurate timestamp
            uploadedAt: r.lastModified || r.updatedAt || r.createdAt || null
          };
        });

        // Update the table
        updateReviewTable(normalized);
        
        // Check if there are still active reviews (pending or processing, not completed or failed)
        const activeReviews = normalized.filter(r => {
          const status = (r.status || '').toLowerCase();
          return status === 'pending' || status === 'processing';
        });
        
        const hasActiveReviews = activeReviews.length > 0;
        
        // Log status check results for debugging
        console.log('[HOME] Status check:', {
          totalReviews: normalized.length,
          activeCount: activeReviews.length,
          statuses: normalized.map(r => ({ id: r.id || r.reviewId, status: r.status })),
          hasActiveReviews
        });
        
        // Hide success message if no active reviews (all completed)
        if (!hasActiveReviews && uploadSuccess) {
          uploadSuccess.hidden = true;
        }
        
        // Stop auto-refresh if no active reviews
        if (!hasActiveReviews && autoRefreshInterval) {
          console.log('[HOME] Auto-refresh stopped - all reviews completed or failed');
          clearInterval(autoRefreshInterval);
          autoRefreshInterval = null;
        } else if (hasActiveReviews && !autoRefreshInterval) {
          // Restart auto-refresh if new active reviews appeared
          console.log('[HOME] Active reviews detected, restarting auto-refresh');
          startAutoRefresh();
        }
        
        // Store last review data for reference
        window.lastReviewData = normalized;
        
      } catch (error) {
        console.error('[HOME] Error updating review history:', error);
        // Stop auto-refresh on network error to prevent continuous failed requests
        if (autoRefreshInterval) {
          clearInterval(autoRefreshInterval);
          autoRefreshInterval = null;
        }
      } finally {
        isRefreshing = false;
      }
    }
    
    // Helper function to create loading dots using DOM (CSP-compliant)
    function createLoadingDots() {
      const container = document.createElement('span');
      container.className = 'loading-dots';
      
      for (let i = 0; i < 3; i++) {
        const dot = document.createElement('span');
        dot.textContent = '.';
        container.appendChild(dot);
      }
      
      return container;
    }
    
    // Helper to create status content with loading dots (CSP-compliant)
    function createStatusContent(cell, status) {
      const statusLower = (status || '').toLowerCase();
      cell.classList.add('govuk-body');
      
      // Clear existing content
      while (cell.firstChild) {
        cell.removeChild(cell.firstChild);
      }
      
      // Map status to display text with three dots
      let displayText = '';
      if (statusLower === 'processing') {
        displayText = 'Processing...';
      } else if (statusLower === 'analyzing') {
        displayText = 'Analyzing...';
      } else if (statusLower === 'reviewing') {
        displayText = 'Reviewing...';
      } else if (statusLower === 'downloading') {
        displayText = 'Downloading...';
      } else if (statusLower === 'finalizing') {
        displayText = 'Finalizing...';
      } else if (statusLower === 'queued') {
        displayText = 'Queued...';
      } else if (statusLower === 'uploading') {
        displayText = 'Uploading...';
      } else if (statusLower === 'uploaded') {
        displayText = 'Uploaded...';
      } else {
        displayText = status;
      }
      
      cell.textContent = displayText;
    }
    
    // Update the review table with new data
    function updateReviewTable(reviews) {
      const tbody = document.getElementById('reviewHistoryBody');
      
      if (!reviews || reviews.length === 0) {
        tbody.innerHTML = '<tr class="govuk-table__row"><td class="govuk-table__cell" colspan="4"><p class="govuk-body">No review history available.</p></td></tr>';
        return;
      }
      
      // Get existing rows mapped by review ID
      const existingRows = new Map();
      const existingRowElements = tbody.querySelectorAll('tr[data-review-id]');
      existingRowElements.forEach(row => {
        const reviewId = row.getAttribute('data-review-id');
        existingRows.set(reviewId, row);
      });
      
      // Clear tbody only if there are no existing rows
      if (existingRows.size === 0) {
        tbody.innerHTML = '';
      }
      
      reviews.forEach((review, index) => {
        const reviewId = review.reviewId || review.id;
        const existingRow = existingRows.get(reviewId);
        
        if (existingRow) {
          // Update Status, Result, and Timestamp columns
          // Timestamp is updated to show S3 LastModified (most accurate time)
          
          const cells = existingRow.querySelectorAll('td');
          // cells[0] = Document Name (keep unchanged)
          // cells[1] = Status (update)
          // cells[2] = Timestamp (update to S3 LastModified)
          // cells[3] = Result (update)
          // cells[4] = Actions (keep unchanged)
          
          if (cells[1]) {
            updateStatusCell(cells[1], review);
          }
          
          // Update timestamp to S3 LastModified for accuracy
          if (cells[2] && review.uploadedAt) {
            const date = new Date(review.uploadedAt);
            cells[2].textContent = date.toLocaleString('en-GB', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            });
          }
          
          if (cells[3]) {
            updateResultCell(cells[3], review);
          }
          
          // Remove from map to track processed rows
          existingRows.delete(reviewId);
        } else {
          // Create new row for new reviews
          const row = createReviewRow(review);
          tbody.appendChild(row);
        }
      });
      
      // Attach delete handlers after updating table
      attachDeleteHandlers();
      
      // Remove rows that are no longer in the response, BUT keep active reviews
      // that were just added client-side (they may not be in backend yet due to S3 delay)
      existingRows.forEach((row, reviewId) => {
        const statusCell = row.querySelector('.govuk-tag');
        const isPending = statusCell && statusCell.classList.contains('govuk-tag--yellow');
        const isProcessing = statusCell && statusCell.classList.contains('govuk-tag--blue');
        
        // Keep pending/processing reviews that might not be in backend yet
        // Remove only completed/failed reviews that disappeared from the limit
        if (!isPending && !isProcessing) {
          row.remove();
        }
      });
      
      // Enforce strict limit: Sort all rows by timestamp and keep only the most recent {limit}
      const currentLimit = parseInt(document.getElementById('reviewLimit')?.value || '5', 10);
      const allRows = Array.from(tbody.querySelectorAll('tr[data-review-id]'));
      
      // Sort rows by timestamp (extract from 3rd cell)
      allRows.sort((a, b) => {
        const aTimestamp = a.cells[2]?.textContent.trim();
        const bTimestamp = b.cells[2]?.textContent.trim();
        
        // Parse UK format: "DD/MM/YYYY, HH:MM"
        const parseUKDate = (str) => {
          if (!str || str === 'N/A') return new Date(0);
          const [datePart, timePart] = str.split(', ');
          const [day, month, year] = datePart.split('/');
          return new Date(`${year}-${month}-${day}T${timePart}:00`);
        };
        
        const aDate = parseUKDate(aTimestamp);
        const bDate = parseUKDate(bTimestamp);
        
        return bDate - aDate; // Most recent first
      });
      
      // Reorder rows in the DOM (most recent first)
      allRows.forEach((row, index) => {
        tbody.appendChild(row); // This moves the row to the end, maintaining sorted order
      });
      
      // Keep only the top {limit} rows, remove the rest (oldest ones)
      if (allRows.length > currentLimit) {
        allRows.slice(currentLimit).forEach(row => row.remove());
      }
    }
    
    // Helper function to create a complete review row (for new reviews)
    function createReviewRow(review) {
      const row = document.createElement('tr');
      row.className = 'govuk-table__row';
      const reviewId = review.reviewId || review.id;
      row.setAttribute('data-review-id', reviewId);
      
      // Document Name (cell 0)
      const filenameCell = document.createElement('td');
      filenameCell.className = 'govuk-table__cell';
      filenameCell.textContent = review.filename || 'N/A';
      row.appendChild(filenameCell);
      
      // Status (cell 1)
      const statusCell = document.createElement('td');
      statusCell.className = 'govuk-table__cell';
      updateStatusCell(statusCell, review);
      row.appendChild(statusCell);
      
      // Timestamp (cell 2)
      const timestampCell = document.createElement('td');
      timestampCell.className = 'govuk-table__cell';
      const timestamp = review.uploadedAt || review.createdAt || review.updatedAt;
      
      if (timestamp) {
        const date = new Date(timestamp);
        timestampCell.textContent = date.toLocaleString('en-GB', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      } else {
        timestampCell.textContent = 'N/A';
      }
      row.appendChild(timestampCell);
      
      // Result (cell 3)
      const resultCell = document.createElement('td');
      resultCell.className = 'govuk-table__cell';
      updateResultCell(resultCell, review);
      row.appendChild(resultCell);
      
      // Actions (cell 4) - Delete button
      const actionsCell = document.createElement('td');
      actionsCell.className = 'govuk-table__cell';
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'govuk-button govuk-button--warning govuk-button--small delete-review-btn';
      deleteBtn.setAttribute('data-review-id', reviewId);
      deleteBtn.setAttribute('data-filename', review.filename || 'Unknown');
      deleteBtn.setAttribute('type', 'button');
      deleteBtn.textContent = 'Delete';
      actionsCell.appendChild(deleteBtn);
      row.appendChild(actionsCell);
      
      return row;
    }
    
    // Helper function to update the Status cell
    function updateStatusCell(cell, review) {
      // Clear existing content
      cell.innerHTML = '';
      
      const statusTag = document.createElement('strong');
      statusTag.className = 'govuk-tag';
      
      const status = (review.status || '').toLowerCase();
      if (status === 'completed') {
        statusTag.classList.add('govuk-tag--green');
        statusTag.textContent = 'Completed';
      } else if (status === 'processing') {
        statusTag.classList.add('govuk-tag--blue');
        createStatusContent(statusTag, 'Processing');
      } else if (status === 'pending') {
        statusTag.classList.add('govuk-tag--yellow');
        createStatusContent(statusTag, 'Pending');
      } else if (status === 'failed') {
        statusTag.classList.add('govuk-tag--red');
        statusTag.textContent = 'Failed';
      } else {
        statusTag.classList.add('govuk-tag--grey');
        statusTag.textContent = review.status ? review.status.charAt(0).toUpperCase() + review.status.slice(1) : 'Unknown';
      }
      
      cell.appendChild(statusTag);
    }
    
    // Helper function to update the Result cell
    function updateResultCell(cell, review) {
      // Clear existing content
      cell.innerHTML = '';
      
      const status = (review.status || '').toLowerCase();
      
      if (status === 'completed') {
        const link = document.createElement('a');
        const reviewIdentifier = review.reviewId || review.id;
        if (!reviewIdentifier) {
          const span = document.createElement('span');
          span.className = 'govuk-hint';
          span.textContent = 'Missing review ID';
          cell.appendChild(span);
        } else {
          link.href = `/review/results/${reviewIdentifier}`;
          link.className = 'govuk-link';
          link.textContent = 'View results';
          cell.appendChild(link);
        }
      } else if (status === 'failed') {
        const errorSpan = document.createElement('span');
        errorSpan.className = 'govuk-error-message';
        if (review.errorMessage) {
          errorSpan.textContent = `Review Failed (${review.errorMessage})`;
        } else {
          errorSpan.textContent = 'Review Failed';
        }
        cell.appendChild(errorSpan);
      } else if (status === 'processing') {
        const span = document.createElement('span');
        span.className = 'govuk-body';
        createStatusContent(span, 'Processing');
        cell.appendChild(span);
      } else if (status === 'pending') {
        const span = document.createElement('span');
        span.className = 'govuk-body';
        createStatusContent(span, 'Pending');
        cell.appendChild(span);
      } else {
        const span = document.createElement('span');
        span.className = 'govuk-body';
        span.textContent = review.status || 'Unknown';
        cell.appendChild(span);
      }
    }
    
    // Delete review functionality
    async function deleteReview(reviewId, filename) {
      if (!reviewId) {
        console.error('[HOME] Cannot delete review - missing ID');
        alert('Error: Missing review ID');
        return;
      }
      
      // Confirm deletion
      const confirmMessage = `Are you sure you want to delete the review for "${filename}"?\n\nThis will permanently delete:\n- The review record\n- Any uploaded content\n- All associated data from S3\n\nThis action cannot be undone.`;
      
      if (!confirm(confirmMessage)) {
        console.log('[HOME] Delete cancelled by user');
        return;
      }
      
      console.log('[HOME] Deleting review:', reviewId);
      
      try {
        // Call delete API endpoint
        const response = await fetch(`/api/reviews/${reviewId}`, {
          method: 'DELETE',
          headers: {
            'Accept': 'application/json'
          }
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `Failed to delete review: ${response.status}`);
        }
        
        const result = await response.json();
        console.log('[HOME] Review deleted successfully:', result);
        
        // Show success message
        alert(`Review "${filename}" has been deleted successfully.`);
        
        // Refresh the review history to update the table
        await updateReviewHistory();
        
      } catch (error) {
        console.error('[HOME] Error deleting review:', error);
        alert(`Failed to delete review: ${error.message}`);
      }
    }
    
    // Attach delete button click handlers
    function attachDeleteHandlers() {
      const deleteButtons = document.querySelectorAll('.delete-review-btn');
      deleteButtons.forEach(button => {
        // Remove existing listeners to prevent duplicates
        button.replaceWith(button.cloneNode(true));
      });
      
      // Re-query and attach new listeners
      const newDeleteButtons = document.querySelectorAll('.delete-review-btn');
      newDeleteButtons.forEach(button => {
        button.addEventListener('click', async function() {
          const reviewId = this.getAttribute('data-review-id');
          const filename = this.getAttribute('data-filename');
          
          // Disable button during deletion
          this.disabled = true;
          const originalText = this.textContent;
          this.textContent = 'Deleting...';
          
          await deleteReview(reviewId, filename);
          
          // Re-enable button (if row still exists)
          if (document.contains(this)) {
            this.disabled = false;
            this.textContent = originalText;
          }
        });
      });
    }
    
    // Attach handlers on page load
    attachDeleteHandlers();
    
    // Start auto-refresh
    function startAutoRefresh() {
      if (autoRefreshInterval) {
        return; // Already running
      }
      
      console.log('[HOME] Starting auto-refresh');
      autoRefreshInterval = setInterval(updateReviewHistory, 5000);
    }
    
    // Make startAutoRefresh globally accessible for upload-handler.js
    window.startAutoRefresh = startAutoRefresh;
    
    // Check if there are any active reviews on page load
    const tableRows = document.querySelectorAll('#reviewHistoryBody tr');
    let hasActiveReviews = false;
    let activeStatuses = [];
    
    tableRows.forEach(row => {
      const statusCell = row.querySelector('.govuk-tag');
      if (statusCell) {
        const statusText = statusCell.textContent.trim().toLowerCase();
        // Only check for pending or processing statuses (not grey/unknown)
        if (statusCell.classList.contains('govuk-tag--blue') ||
            statusCell.classList.contains('govuk-tag--yellow')) {
          hasActiveReviews = true;
          activeStatuses.push(statusText);
        }
      }
    });
    
    // Start auto-refresh if there are active reviews
    if (hasActiveReviews) {
      console.log('[HOME] Active reviews detected on page load:', {
        count: activeStatuses.length,
        statuses: activeStatuses
      });
      // Do an immediate update first to get latest status
      updateReviewHistory();
      // Then start the interval
      startAutoRefresh();
    } else {
      console.log('[HOME] No active reviews on page load - auto-refresh not started');
    }
    
    // Clean up interval when page is unloaded
    window.addEventListener('beforeunload', () => {
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
      }
    });
  </script>
{% endblock %}
