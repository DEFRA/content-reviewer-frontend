import PDFDocument from 'pdfkit'
import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType
} from 'docx'

/**
 * Fetch review results from backend API
 */
async function fetchReviewResults(id, request) {
  try {
    const config = request.server.app.config
    const backendUrl = config.get('backendUrl')

    const response = await fetch(`${backendUrl}/api/results/${id}`)
    if (!response.ok) {
      throw new Error(`Failed to fetch review results: ${response.status}`)
    }

    const apiResponse = await response.json()
    if (!apiResponse.success || !apiResponse.data) {
      throw new Error('Invalid response from backend')
    }

    return transformReviewData(apiResponse.data)
  } catch (error) {
    request.logger.error(
      { error: error.message, reviewId: id },
      'Failed to fetch review data for export'
    )
    throw error
  }
}

/**
 * Transform backend status data to export format
 */
function transformReviewData(statusData, reviewId) {
  // Only consume and expose the API response attributes provided
  // { id, jobId, status, result: { reviewContent, guardrailAssessment, stopReason, completedAt }, completedAt }

  const safeResult = statusData.result || {}

  return {
    id: statusData.id || reviewId,
    jobId: statusData.jobId,
    status: statusData.status,
    result: {
      reviewContent: safeResult.reviewContent,
      guardrailAssessment: safeResult.guardrailAssessment,
      stopReason: safeResult.stopReason
    },
    completedAt: statusData.completedAt,

    // Keep raw data for export buttons
    rawData: statusData
  }
}

export const exportController = {
  /**
   * Export review results as PDF
   */
  exportPdf: async (request, h) => {
    const { id } = request.params

    try {
      const results = await fetchReviewResults(id, request)
      const rawData = results.rawData || results

      // Create PDF document
      const doc = new PDFDocument({ margin: 50 })
      const chunks = []

      // Collect PDF data
      doc.on('data', (chunk) => chunks.push(chunk))

      return new Promise((resolve) => {
        doc.on('end', () => {
          const pdfBuffer = Buffer.concat(chunks)
          const response = h.response(pdfBuffer)
          response.type('application/pdf')
          response.header(
            'Content-Disposition',
            `attachment; filename="review-results-${id}.pdf"`
          )
          resolve(response)
        })

        // Header
        doc
          .fontSize(24)
          .text('GOV.UK Content Review Results', { align: 'center' })
        doc.moveDown()

        // Document Information
        doc.fontSize(16).text('Document Information', { underline: true })
        doc.moveDown(0.5)
        doc.fontSize(12)
        doc.text(`Document: ${rawData.fileName || 'N/A'}`)
        doc.text(`Review ID: ${rawData.id || id}`)
        doc.text(`Status: ${rawData.status || 'N/A'}`)
        doc.text(
          `Created: ${rawData.createdAt ? new Date(rawData.createdAt).toLocaleString('en-GB') : 'N/A'}`
        )
        doc.text(
          `Updated: ${rawData.updatedAt ? new Date(rawData.updatedAt).toLocaleString('en-GB') : 'N/A'}`
        )
        if (rawData.completedAt) {
          doc.text(
            `Completed: ${new Date(rawData.completedAt).toLocaleString('en-GB')}`
          )
        }
        doc.moveDown()

        // Review Content
        if (rawData.result && rawData.result.reviewContent) {
          doc.addPage()
          doc.fontSize(16).text('Review Content', { underline: true })
          doc.moveDown(0.5)
          doc
            .fontSize(11)
            .text(rawData.result.reviewContent, { align: 'justify' })
          doc.moveDown()
        }

        // Additional Result Data
        if (rawData.result) {
          if (rawData.result.guardrailAssessment) {
            doc.addPage()
            doc.fontSize(16).text('Guardrail Assessment', { underline: true })
            doc.moveDown(0.5)
            doc
              .fontSize(11)
              .text(JSON.stringify(rawData.result.guardrailAssessment, null, 2))
            doc.moveDown()
          }

          if (rawData.result.stopReason) {
            doc.fontSize(14).text('Stop Reason', { underline: true })
            doc.moveDown(0.5)
            doc.fontSize(11).text(rawData.result.stopReason)
            doc.moveDown()
          }
        }

        // Footer
        doc.moveDown(2)
        doc.fontSize(10).fillColor('gray')
        doc.text('Generated by GOV.UK Content Review Tool', { align: 'center' })
        doc.text(`Report ID: ${id}`, { align: 'center' })
        doc.text(`Generated on: ${new Date().toLocaleString('en-GB')}`, {
          align: 'center'
        })

        doc.end()
      })
    } catch (error) {
      request.logger.error(
        { error: error.message, reviewId: id },
        'Failed to generate PDF export'
      )
      return h.response({ error: 'Failed to generate PDF export' }).code(500)
    }
  },

  /**
   * Export review results as Word document
   */
  exportWord: async (request, h) => {
    const { id } = request.params

    try {
      const results = await fetchReviewResults(id, request)
      const rawData = results.rawData || results

      // Create document sections
      const sections = [
        {
          children: [
            // Title
            new Paragraph({
              text: 'GOV.UK Content Review Results',
              heading: HeadingLevel.HEADING_1,
              alignment: AlignmentType.CENTER,
              spacing: { after: 400 }
            }),

            // Document Information
            new Paragraph({
              text: 'Document Information',
              heading: HeadingLevel.HEADING_2,
              spacing: { before: 200, after: 200 }
            }),
            new Paragraph({
              children: [
                new TextRun({ text: 'Document: ', bold: true }),
                new TextRun(rawData.fileName || 'N/A')
              ]
            }),
            new Paragraph({
              children: [
                new TextRun({ text: 'Review ID: ', bold: true }),
                new TextRun(rawData.id || id)
              ]
            }),
            new Paragraph({
              children: [
                new TextRun({ text: 'Status: ', bold: true }),
                new TextRun(rawData.status || 'N/A')
              ]
            }),
            new Paragraph({
              children: [
                new TextRun({ text: 'Created: ', bold: true }),
                new TextRun(
                  rawData.createdAt
                    ? new Date(rawData.createdAt).toLocaleString('en-GB')
                    : 'N/A'
                )
              ]
            }),
            new Paragraph({
              children: [
                new TextRun({ text: 'Updated: ', bold: true }),
                new TextRun(
                  rawData.updatedAt
                    ? new Date(rawData.updatedAt).toLocaleString('en-GB')
                    : 'N/A'
                )
              ],
              spacing: { after: 200 }
            }),

            // Review Content
            new Paragraph({
              text: 'Review Content',
              heading: HeadingLevel.HEADING_2,
              spacing: { before: 400, after: 200 }
            }),
            new Paragraph({
              text:
                (rawData.result && rawData.result.reviewContent) ||
                'No review content available',
              spacing: { after: 400 }
            }),

            // Footer
            new Paragraph({
              children: [
                new TextRun({
                  text: '\n\nGenerated by GOV.UK Content Review Tool',
                  italics: true,
                  size: 20
                }),
                new TextRun({
                  text: `\nReport ID: ${id}`,
                  italics: true,
                  size: 20
                }),
                new TextRun({
                  text: `\nGenerated on: ${new Date().toLocaleString('en-GB')}`,
                  italics: true,
                  size: 20
                })
              ],
              alignment: AlignmentType.CENTER,
              spacing: { before: 600 }
            })
          ]
        }
      ]

      // Create document
      const doc = new Document({ sections })

      // Generate buffer
      const buffer = await Packer.toBuffer(doc)

      const response = h.response(buffer)
      response.type(
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      )
      response.header(
        'Content-Disposition',
        `attachment; filename="review-results-${id}.docx"`
      )
      return response
    } catch (error) {
      request.logger.error(
        { error: error.message, reviewId: id },
        'Failed to generate Word export'
      )
      return h.response({ error: 'Failed to generate Word export' }).code(500)
    }
  }
}
