import PDFDocument from 'pdfkit'
import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType
} from 'docx'
import { getReviewResults } from '../results/data-service.js'

export const exportController = {
  /**
   * Export review results as PDF
   */
  exportPdf: async (request, h) => {
    const { id } = request.params
    const results = getReviewResults(id)

    // Create PDF document
    const doc = new PDFDocument({ margin: 50 })
    const chunks = []

    // Collect PDF data
    doc.on('data', (chunk) => chunks.push(chunk))

    return new Promise((resolve) => {
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(chunks)
        const response = h.response(pdfBuffer)
        response.type('application/pdf')
        response.header(
          'Content-Disposition',
          `attachment; filename="review-results-${id}.pdf"`
        )
        resolve(response)
      })

      // Header
      doc.fontSize(24).text('Content Review Results', { align: 'center' })
      doc.moveDown()

      // Document Information
      doc.fontSize(16).text('Document Information', { underline: true })
      doc.moveDown(0.5)
      doc.fontSize(12)
      doc.text(`Document: ${results.documentName}`)
      doc.text(
        `Review Date: ${new Date(results.reviewDate).toLocaleString('en-GB')}`
      )
      doc.text(`Status: ${results.status}`)
      doc.text(`LLM Model: ${results.llmModel}`)
      doc.text(`Processing Time: ${results.processingTime}`)
      doc.moveDown()

      // Summary
      doc.fontSize(16).text('Summary', { underline: true })
      doc.moveDown(0.5)
      doc.fontSize(12)
      doc.text(`Overall Score: ${results.summary.overallScore}/100`)
      doc.text(`Readability: ${results.summary.readabilityScore}`)
      doc.text(`Compliance: ${results.summary.complianceScore}`)
      doc.text(`Issues Found: ${results.summary.issuesFound}`)
      doc.text(`Word Count: ${results.summary.wordCount}`)
      doc.text(
        `Average Sentence Length: ${results.summary.averageSentenceLength} words`
      )
      doc.moveDown()

      // Findings
      doc.fontSize(16).text('Findings', { underline: true })
      doc.moveDown(0.5)

      results.findings.forEach((finding, index) => {
        doc
          .fontSize(14)
          .fillColor('red')
          .text(`${index + 1}. ${finding.category} (${finding.severity})`, {
            continued: false
          })
        doc.fillColor('black')
        doc
          .fontSize(11)
          .text(`AI Confidence: ${Math.round(finding.aiConfidence * 100)}%`)
        doc.fontSize(12)
        doc.text(`Issue: ${finding.description}`)
        doc.text(`Location: ${finding.location}`)
        doc.text(`Suggestion: ${finding.suggestion}`)
        doc.moveDown()
      })

      // Recommendations
      doc.addPage()
      doc.fontSize(16).text('Recommendations', { underline: true })
      doc.moveDown(0.5)
      doc.fontSize(12)

      results.recommendations.forEach((rec, index) => {
        doc.text(`${index + 1}. ${rec}`)
      })

      // Footer
      doc.moveDown(2)
      doc.fontSize(10).fillColor('gray')
      doc.text('Generated by Content Review Tool', { align: 'center' })
      doc.text(`Report ID: ${id}`, { align: 'center' })

      doc.end()
    })
  },

  /**
   * Export review results as Word document
   */
  exportWord: async (request, h) => {
    const { id } = request.params
    const results = getReviewResults(id)

    // Create document sections
    const sections = [
      {
        children: [
          // Title
          new Paragraph({
            text: 'Content Review Results',
            heading: HeadingLevel.HEADING_1,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 }
          }),

          // Document Information
          new Paragraph({
            text: 'Document Information',
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 200, after: 200 }
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Document: ', bold: true }),
              new TextRun(results.documentName)
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Review Date: ', bold: true }),
              new TextRun(new Date(results.reviewDate).toLocaleString('en-GB'))
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Status: ', bold: true }),
              new TextRun(results.status)
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'LLM Model: ', bold: true }),
              new TextRun(results.llmModel)
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Processing Time: ', bold: true }),
              new TextRun(results.processingTime)
            ],
            spacing: { after: 200 }
          }),

          // Summary
          new Paragraph({
            text: 'Summary',
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 400, after: 200 }
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Overall Score: ', bold: true }),
              new TextRun(`${results.summary.overallScore}/100`)
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Readability: ', bold: true }),
              new TextRun(results.summary.readabilityScore)
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Compliance: ', bold: true }),
              new TextRun(results.summary.complianceScore)
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Issues Found: ', bold: true }),
              new TextRun(String(results.summary.issuesFound))
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Word Count: ', bold: true }),
              new TextRun(String(results.summary.wordCount))
            ]
          }),
          new Paragraph({
            children: [
              new TextRun({ text: 'Average Sentence Length: ', bold: true }),
              new TextRun(`${results.summary.averageSentenceLength} words`)
            ],
            spacing: { after: 200 }
          }),

          // Findings
          new Paragraph({
            text: 'Findings',
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 400, after: 200 }
          })
        ]
      }
    ]

    // Add each finding
    results.findings.forEach((finding, index) => {
      sections[0].children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${index + 1}. ${finding.category} `,
              bold: true
            }),
            new TextRun({
              text: `(${finding.severity})`,
              color:
                finding.severity === 'High'
                  ? 'FF0000'
                  : finding.severity === 'Medium'
                    ? 'FFA500'
                    : '808080',
              bold: true
            })
          ],
          spacing: { before: 200 }
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'AI Confidence: ', italics: true }),
            new TextRun({
              text: `${Math.round(finding.aiConfidence * 100)}%`,
              italics: true
            })
          ]
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'Issue: ', bold: true }),
            new TextRun(finding.description)
          ]
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'Location: ', bold: true }),
            new TextRun(finding.location)
          ]
        }),
        new Paragraph({
          children: [
            new TextRun({ text: 'Suggestion: ', bold: true }),
            new TextRun(finding.suggestion)
          ],
          spacing: { after: 200 }
        })
      )
    })

    // Recommendations
    sections[0].children.push(
      new Paragraph({
        text: 'Recommendations',
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 400, after: 200 }
      })
    )

    results.recommendations.forEach((rec, index) => {
      sections[0].children.push(
        new Paragraph({
          text: `${index + 1}. ${rec}`,
          numbering: {
            reference: 'recommendations',
            level: 0
          }
        })
      )
    })

    // Footer
    sections[0].children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: '\n\nGenerated by Content Review Tool',
            italics: true,
            size: 20
          }),
          new TextRun({ text: `\nReport ID: ${id}`, italics: true, size: 20 })
        ],
        alignment: AlignmentType.CENTER,
        spacing: { before: 600 }
      })
    )

    // Create document
    const doc = new Document({
      sections,
      numbering: {
        config: [
          {
            reference: 'recommendations',
            levels: [
              {
                level: 0,
                format: 'decimal',
                text: '%1.',
                alignment: AlignmentType.START
              }
            ]
          }
        ]
      }
    })

    // Generate buffer
    const buffer = await Packer.toBuffer(doc)

    const response = h.response(buffer)
    response.type(
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    )
    response.header(
      'Content-Disposition',
      `attachment; filename="review-results-${id}.docx"`
    )
    return response
  }
}
